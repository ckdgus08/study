# 13장 서브클래싱과 서브타이핑

### **상속의 용도**

- 타입 계층 구현 (지향)
    - 부모 클래스 : 일반적인 개념을 구현 (일반화)
    - 자식 클래스 : 특수한 개념을 구현 (특수화)
- 코드 재사용 (단순 코드 재사용을 위한 목적이라면, 상속을 지양하자)
    - why? : 부모와 자식간의 결합도가 높아짐 → 변경하기 어려운 코드

### **13장을 읽고나면?**

- 서브 타이핑 : 인터페이스 상속, 타입 계층 구현, 지향 ⇒ 항상 클라이언트 관점에서 생각해야한다.
라는게 결론이고, 밑에서 왜?? 에 대한 이유를 예시
- 서브 클래싱 : 구현상속, 코드 재사용, 지양

---

### 타입계층?

![스크린샷 2021-11-07 오후 3.51.09.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.51.09.png?raw=true)

![스크린샷 2021-11-07 오후 3.51.27.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.51.27.png?raw=true)

그림에서 슈퍼타입, 서브타입 살펴보기.

- 일반화, 추상화
    - 객체지향 언어, 절치적 언어 → 프로그래밍 언어
    - 클래스 기반 언어, 프토로타입 기반 언어 → 객체지향 언어
    - 범용적이고 넓은 의미
    - 반대는 구체화, 특수화
- 일반적인 타입과 구체적인 타입의 관계를 결정하는건 퍼블릭 인터페이스

**서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.**

ex) Number number = new Integer("1");

---

### 서브클래싱과 서브타이핑

- 언제 상속을 사용? (마틴 오더스키 - 스칼라 창시자, 객체지향 + 함수형 조합 연구)
    - 두가지 전부 yes 일때 상속 사용
    - 설계관점에서 상속을 적용할지 여부를 결정하려면 2번째 질문에 초점

![스크린샷 2021-11-07 오후 6.26.08.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.26.08.png?raw=true)

- is-a 관계?
    - 객체지향 언어 is - a 프로그래밍 언어
    - 펭귄 vs 새
        - 펭귄은 새다.
        - 새는 날 수 있다.
        - is-a 관계 일까??
            
            ```java
            public class Bird {
            	public void fly() {...}
            }
            
            public class Penguin extends Bird {
            	...
            }
            ```
            
        - 정답
            
            no.
            펭귄은 새 이지만, 날수 없다. but 코드에서는 펭귄은 새고, 날 수 있다. 로 표현되어 있음.
            
            ex) fly가 아니고 lay 알을 낳다. 이면 is-a 관계가 될 것 임.
            
- 행동 호환성
    - 새와, 펭귄의 서로 다른 행동방식은 이 둘을 동일한 타입 계층으로 묶어서는 안된다고 경고한다.
    - 호환 여부를 판단하는 것은 클라이언트 기준
- 상속을 유지하면서, 위 문제를 해결해보기
    
    ```java
    public class Penguin extends Bird {
    	@Override
    	public void fly() {}
    }
    ```
    
    ⇒ fly 함수를 사용하는 사용자의 기대를 만족시키지 못한다. 올바른 설계가 아니다.
    
    ```java
    public class Penguin extends Bird {
    	@Override
    	public void fly() {
    		throw new UnsupportedOperatationException();
    	}
    }
    ```
    
    ⇒ 마찬가지로, 사용자의 기대와 다른 결과가 일어나므로, 올바른 설계가 아니다.
    
    ```java
    public void flyBird(Bird bird) {
    	if(!(bird instanceof Penguine)) {
    		 bird.fly();
    	}
    }
    ```
    
    ⇒ 펭귄 이외에 또 다른 날지 못하는 새(타조, 닭) 이 추가되면 if문 조건에 추가해줘야함.
    
    ⇒ new 연산과 마찬가지로 결합도를 높힌다. 새로운 타입이 추가되면 코드 수정이 필요함.
    
- 또 다르게 해결해보기
    - 클라이언트의 기대에 따라 상속 계층을 분리
        
        ![스크린샷 2021-11-07 오후 9.52.26.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.52.26.png?raw=true)
        
    
    커버해야 하는 경우의 수가 추가 된다면? ex) 말을 할 수 있는 새
    
    - 
        
        ![스크린샷 2021-11-07 오후 10.25.01.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.25.01.png?raw=true)
        
    
    가장 좋은 방법은 fly 오페레이션을 가진 Flyer 인터페이스와 walk 오퍼레이션을 가진 Walker 인터페이스로 분리 하는 것
    
- Panguin이 bird 함수를 재사용 해야한다면?
    - 상속을 받으면 문법적으로 문제는 없다. but fly 오퍼레이션이 추가 됨. and 재사용을 위한 상속은 위험
    - 
        
        ![스크린샷 2021-11-07 오후 10.35.25.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.35.25.png?raw=true)
        
- 인터페이스 분리 원칙
- 설계가 꼭 현실 세계를 반영 할 필요는 없다.
    - 현재의 요구사항이 날 수 있는 행동에 관심이 없다면, 굳이 FlyingBird와 Panguin을 구분 할 필요가 없다.
    - 오버엔지니어링으로 요구사항만 복잡하게 만들 뿐이다.
    - 현실을 정확하게 묘사하는 것이 아니라, 요구사항을 실용적으로 수용하는 것을 목표로 삼아야한다.

### 리스코프 치환 원칙

- 올바른 상속관계를 구축하기 위한 지침은  행동호환성 + 대체 가능성 이고 이 책에서는 리스코프 치환 원칙 이라는 이름으로 정리
    - 아까 위에서는 is-a + 행동호환성 이라고 했는데...???? 라고 생각했는데 뒤에서 답을 해줌.
- 리스코프 치환 원칙을 설명하는 워딩
    - 서브타입은 그것의 기반 타입에 대체 가능해야 한다.
    - 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 위반 사례
    - Bird, Panguin
    - 정사각형은 직사각형이다. (잘못된 소개 된 것.. 직사각형은 네 각의 크기가 같을때..인데 길이로 설명하고 있음....)
        - 직사각형은 가로, 세로 길이가 다르다.
        - 정사각형은 가로, 세로 길이가 같다.
    - stack, vector
- 행동 호환성과 리스코프 치환 원칙에서 한가지만 기억해야 한다면, 대체 가능성을 결정하는 것은 클라이언트이다.

### is-a 다시 살펴보기

- (클라이언트의 입장에서) 를 앞에 붙혀서 생각해보자.
- (클라이언트의 입장에서) 펭귄은 새다.
- (클라이언트의 입장에서) 정사각형은 직사각형이다.

### 계약에 의한 설계와 서브타이핑

- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서 클라이언트와 슈퍼타입 간에 체결된 "계약"을 준수해야 한다.
    - 예시 1)
        - client1 과 Flyer  - 날수 있어야한다. 라는 계약
        - client2 와 Walker - 걸을수 있어야 한다. 라는 계약
            
            ![스크린샷 2021-11-07 오후 10.25.01.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.25.01.png?raw=true)
            
    - 예시 2)
        - Movie  와 협력하는 DiscountPolicy 에 대해 생각
            
            ![스크린샷 2021-11-08 오전 1.07.54.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.07.54.png?raw=true)
            
        - movice 라는 클라이언트와 DiscountPolicy 간의 계약은 어떤게 있을까?
            - 암묵적인 사전조건
                - screening이 null이 아니다.
                - screening   StartTime이 현재시간 이후이다.
            - 암묵적인 사후 조건
                - fee는 null이 아니여야 한다.
                - fee는 항상 0보다 크거나 같은 값이여야 한다.
                    
                    ![스크린샷 2021-11-08 오전 1.15.44.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.15.44.png?raw=true)
                    
                    ![스크린샷 2021-11-08 오전 1.16.01.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.16.01.png?raw=true)
                    
                    ![스크린샷 2021-11-08 오전 1.14.30.png](https://github.com/ckdgus08/study/blob/master/image/13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B5%E1%86%BC%20/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-11-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.14.30.png?raw=true)
                    

### 서브타입과 계약

- 부모 클래스에 정의된 계약 조건을  상속 후 오버라이딩하여 재정의 한다면???
    - 서브타입에 더 강력한 사전조건을 정의 할 수 없다.
        - Movie ↔ DiscountPolicy
        - DiscountPolicy를 상속한 NewDiscountPolicy 새로운 사전 조건
            
            12시 이후에는 영화를 예약못한다!
            
        - DiscountPolicy policy = new NewDiscountPolicy();
        - 업케스팅시, Movie는 DiscountPolicy 의 사전조건만 알고 있음.
    - 서브타입에 슈퍼타입과 겉거나 더 약한 사전조건을 정의할 수 있다.
    - 서브타입에 슈퍼타입과 같더나 더 강한 사후조건을 정의할 수 있다.
    - 서브타입에 더 약한 사후조건을 정의 할 수 없다.
    
    ### 계약에 의한 설계의 일부만 살펴봄, 부록 A에서 더 자세한 내용을 다룸.
    
    ### 상속이 아닌 방법으로, 타입계층 구현하기 부록 B에서 다룸.