## 서론

- 사람의 기억은 장기기억과 단기기억으로 분류가능한데 장기기억은 쉽게 접근 불가능하고, 단기기억으로 옮긴후 연산함
    - 밀러의 법칙에 의해 동시에 처리하는 량이 많치 않다(5~9개 정도의 정보 처리가능)
    - 이 단기기억 용량을 초과하면 급격히 문제해결능력이 떨어진다 → **인지과부하**
    - 인지과부하 방지를 위해 정보양을 조절해서 다뤄야한다
    - 따라서 문제해결을 위한 필요한 핵심만 남기는 것이 **추상화**
        - 인간의 단기 기억은 한정되어 있으므로 한 번에 너무 많은 정보를 마주하면 이해하기가 어렵다. 추상화를 해서 단기 기억 레벨에서 쉽게 이해할 수 있도록 만든다.
- 한번에 해결하기 어려운 문제는 추상화하기 어려우니 여러 작은 문제로 나눈다
    - 그래도 어려우면 또 나눔
    - 이과정을 **decomposition(분해)**
    - 소프트웨어 개발 영역에서 어려운 문제를 풀기 위해 추상화와 분해가 사용됨

## 프로시저 추상화와 데이터 추상화

- 프로시저 추상화 : 프로그램이 무엇을 해야하는지를 추상화
    - 기능 분해(알고리즘 분해)
    - 프로시저 →input을 받아서 output내는 하나의 수학 함수
- 데이터 추상화 : 프로그램이 무엇을 알아야 하는지를 추상화
    - 데이터를 중심으로 타입을 추상화 → ADT
    - 데이터를 중심으로 프로시저를 추상화 → Object-Oriented
- 객체지향 → 위 두가지를 추상화를 함꼐 포함한 클래스를 이용해 시스템을 분리

## 프로시저 추상화와 기능분해

- 시스템을 메인 함수부터 쪼개서 시작되는 기능분해
    - 하향식 접근
    - 가장 최상위 기능을 정의하고 덜 추상적인 하위기능으로 분해해가며 기능 구현
- 급여관리 시스템

    ```jsx
    직원의 급여를 계산한다.(최상위 기능)
        사용자로부터 소득세율을 입력받는다.(getTaxRate)
            "세율을 입력하세요: " 라는 문장을 화면에 출력한다.(print **)
            키보드를 통해 세율을 입력받는다.(return gets.keyboard)
        직원의 급여를 계산한다.(caculatePayFor)
            전역 변수에 저장된 직원의 기본급 정보를 얻는다.(index = employee.index **)
            급여를 계산한다.(basePay = **)
        양식에 맞게 결과를 출력한다.(describeResult)
            "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.(return 이름 급여)
    ```

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb709f63-a1ce-4cc6-915b-2a19ee477049/Untitled.png)

    - 급여관리 시스템을 하나의 커다란 메인함수로 잡고 기능 분해
    - 무대의 주연은 기능이며 데이터가 기능을 보조하는 조연
    - 이것은 다양한 유지보수 문제를 야기함
        - 이것은 객체지향의 장점을 이해하는 좋은 출발점
- 하향식 기능 분해의 문제점
    - 시스템은 하나의 메인함수로 구현되어 있지 않음
        - 대부분의 시스템에서 하나의 메인 기능이란 존재하지 않음
        - 현대의 시스템은 동등한 수준의 다양한 기능으로 구성된다.
        - 실제 시스템에 정상(top)이란 존재하지 않는다.
    - 기능 추가나 요구사항 변경으로 인해 메인함수를 빈번하게 수정되어야함
        - 시스템 안에는 여러개의 정상이 존재하기 떄문에, 유일한 정상으로 간주하는 하향식 기능 분해는 기능 추가시 메인 함수 수정을 동반한다.
            - 예를 들면 현재 main함수는 각 개인의 급여 계산(input으로 name을 받았음)

                ```jsx
                def main(name)
                  taxRate = getTaxRate()
                  pay = calculatePayFor(name, taxRate)
                  puts(describeResult(name, pay))
                end
                ```

            - 갑자기 전체 급여 총합 기능도 구현되어야 하면 main 함수가 급격히 바껴야함.

                ```jsx
                def main(operation, args={})
                  case(operation)
                  when :pay then calculatePay(args[:name])
                  when :basePays then sumOfBasePays()
                  end
                end
                ```

    - 비지니스 로직이 사용자 인터페이스와 강하게 결합된다.
        - 사용자로부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력한다.
        - 사용자 인터페이스 부분의 변경(입력 UI)와 계산 비지니스 로직(급여산정로직)의 변경 빈도가 다르다 → 관심사의 분리
    - 하향식 분해는 너무 이른시기에 함수들의 실행순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
        - 무엇을 실행하는가 보다는 어떻게 실행하는지 구현에 초점이 맞춰져 있음
            - 함수들의 실행순서를 정의하는 시간제약을 강조한다. → 어떤 순서로 실행돼야 하는가?(미리 실행순서를 결정해야 됨)
            - 중앙 집중 제어 스타일의 형태를 띠게 됨 → 상위함수에서 모든 결정이 이뤄지고 하위 함수는 상위함수의 흐름에 따라 적절한 순서에 실행
            - 문제는 함수의 제어 구조가 빈번하게 수정된다는 것
                - 기능이 추가되거나 변경될때 해당 제어구조가 올바르지 않을 경우가 많기 때문
        - 논리적 제약을 설계의 기준으로 삼아야 한다.
            - 객체 사이의 논리적인 관계를중심으로 설계
            - 하나의 구성요소가 제어가 집중되는 것이 아니라 여러 객체로 분산
        - 상위함수가 강요하는 문맥에 강하게 결합되어(강결합) 변경에 취약하게 만들고 이해하기 어렵게 만든다.
    - 데이터 형식이 변경될 경우 사이드이펙트를 예측할 수 없다.
        - 데이터가 어느 함수에서 사용되고 있는지 모두 파악하기 어렵기 때문에 변경사항 추적이 어려움
            - 급여계산시스템에서 시급 아르바이트 직원을 추가한다고 하면, 모든 함수에 해당 데이터를 변경해야된다.
                - calculatePay 만 변경하면
                - sumOfBasePays 변경을 하지 않아 비지니스 오류가 남
- 언제 하향식 분해가 유용한가?
    - 완전히 이해한 사실을 서술하는데 적합하다.
    - 그런데 새로운것을 만들어 내는데 좋지 않음.
        - 재사용이 어렵기 떄문
    - 작은 프로그램 이나 개별 알고리즘에 유용

## 모듈

- 정보 은닉
    - 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 숨기는 것으로 시스템을 모듈 단위로 나누기 위해 사용되는 기본 원리
- 모듈이 감춰야 하는 것
    - 복잡성
        - 모듈이 너무 복잡하면, 이해하고 사용하기 어렵기 때문에 간단한 인터페이스로 외부에 추상화하여 제공
    - 변경 가능성
        - 변경 가능한 설계 결정을 모듈 내부로 숨긴다면 오직 변경에 대한 수정은 모듈내에서 이루어지면 됨
            - 만약 외부에 노출되면 변경할때마다 외부도 변경해주어야 함
- 일반적인 비밀은 데이터 이긴 하지만 반드시 데이터 인것은 아니다.
    - 복잡한 로직일 수도 있다고 함 → 뭔가 계산 로직 말하는건가?

        ```jsx
        def calculatePay(name)
          taxRate = getTaxRate()
          if (hourly?(name)) then
            pay = calculateHourlyPayFor(name, taxRate)
          else
            pay = calculatePayFor(name, taxRate)
          end
          puts(describeResult(name, pay))
        end
        ```

        ```jsx
        def calculatePay(name)
          taxRate = getTaxRate()
          pay = Employees.calculatePay(name, taxRate)
          puts(describeResult(name, pay))
        end
        ```

      employee가 시급제인지 아닌지 로직에서 알필요는 없음

- 데이터 캡슐화란 결국 데이터를 감추고 퍼블릭 인터페이스를 통해서 접근할 수 있게 하는 것

### 모듈의 장점

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
- 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
    - 입력을 받는 인터페이스 로직과 비지니스 로직은 완전분리
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.
    - 다른모듈에서도 동일한 이름을 사용할 수 있게하여 충돌 방지

결론적으로 비밀과 관련성 높은 데이터(+프로시저)를 잘 감춰서, **높은 응집도**를 유지하고 모듈과 모듈사이에는 퍼블릭 인터페이스를 통해서 통신하여 **낮은 결합도**를 유지

### 모듈의 한계

- 프로시저 추상화보다 높은 추상화 개념을 제공하지만 태생적으로 변경을 관리하기 위한 구현기법이기에 추상화 관점에서 한계가 있다.
    - 회사에 속한 모든 직원의 정보를 가지고 있는 모듈이지 개별 직원에 대한 독립적인 추상화가 아님
- 더 높은 추상화를 하려면 독립적인 단위로 추상화해야되는데 그게 추상 데이터 타입

## 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

- 타입
    - 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미
        - 정수타입의 변수는 사칙연산을 이용해 값을 변화시킬 수 있고, 임의의 정숫값을 예상할 수 있다.
- 바바라 리스코프는 프로시저만의 추상화 만으로는 한계를 인지하고 보완하기 위해 데이터 추상화(ADT) 개념을 제안
    - 추상화가 한단계 발전함
- 예
    - 직원의 급여를 계산하다
        - 하나의 커다란 절차로 각 직원의 급여를 가져와서 계산 x
        - '직원', '급여' 의 추상적인 개념들을 이용해 '계산' 하는 절차

### 추상 데이터 타입을 구현하기 위한 PL의 특성

- 타입 정의를 선언할 수 있어야 한다.
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
- 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.
- (but)프로그래밍 언어가 지원안한다고 추상데이터타입 구현이 불가능한것이 아님
    - 객체지향 언어를 사용하지 않아도 객체지향 프로그래밍을 할 수는 있다.
- module만 했을때

    ```jsx
    module Employees
      $employees = ["직원A", "직원B", "직원C", "아르바이트D", "아르바이트E", "아르바이트F"]
      $basePays = [400, 300, 250, 1, 1, 1.5]
      $hourlys = [false, false, false, true, true, true]
      $timeCards = [0, 0, 0, 120, 120, 120]
    ```

- ADT까지 헀을떄

    ```jsx
    $employees = [
      Employee.new("직원A", 400, false, 0),
      Employee.new("직원B", 300, false, 0),
      Employee.new("직원C", 250, false, 0),
      Employee.new("아르바이트D", 1, true, 120),
      Employee.new("아르바이트E", 1, true, 120),
      Employee.new("아르바이트F", 1, true, 120),
    ]
    ```

    - 흠... 아직 클래스가 안나와서 그렇구나..
    - 처음에 별 차이점을 못느꼈음
- 결론
    - ADT는 객체를 독립적으로 생성하는데, 아직 데이터와 기능을 분리해서 바라본다.
        - 절차적인 틀에 갇혀 있다는게 무슨 말일까?...
    - ADT로 표현되는 데이터를 이용해서 기능을 구현하는 핵심로직은 추상데이터 외부에 존재한다.

        ```jsx
        def main(operation, args={})
          case(operation)
          when :pay then calculatePay(args[:name])
          when :basePays then sumOfBasePays()
          end
        end
        
        def calculatePay(name)
          taxRate = getTaxRate()
          for each in $employees
            if (each.name == name) then employee = each; break end
          end
          pay = employee.calculatePay(taxRate)
          puts(describeResult(name, pay))
        end
        ```

    - employes를 사용하는 calculatePay의 핵심로직은 외부에 존재

## 클래스

- 클래스와 추상데이터 타입 모두 데이터 추상화를 기반으로 시스템을 분해하지만 차이가 있음
    - 클래스는 상속과 다형성을 지원하지만 추상 데이터 타입은 지원하지 않는다.
    - 추상 데이터 타입은 타입을 추상화한 것 (오퍼레이션 기준으로 타입을 통합)

      ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c04634df-2906-445c-b051-21ec423884fa/Untitled.png)

        - 개별적인 오퍼레이션 마다 타입에 대한 구현을 포괄하여 하나의 오퍼레이션이 동작함

            ```jsx
            def calculatePay(taxRate)
                if (hourly) then
                  return calculateHourlyPay(taxRate)
                end
                return calculateSalariedPay(taxRate)
            end
            ```

    - 클래스는 절차를 통합한 것(타입을 기준으로 오퍼레이션을 묶는다)

      ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e87b76b6-06c2-46ec-8054-a9e80123c549/Untitled.png)

        - 타입을 기준으로 오퍼레이션을 묶음

            ```jsx
            class SalariedEmployee < Employee
              def initialize(name, basePay)
                super(name, basePay)
              end
                
              def calculatePay(taxRate)
                return basePay - (basePay * taxRate)
              end
              
              def monthlyBasePay()
                return basePay
              end
            end
            ```

        - 두개 이상 클래스가 분리될 경우 공통로직 위치 이슈가 있음
            - 부모클래스에 정의하고 상속 받으면 됨
        - 클라이언트는 부모 클래스의 참조자에 대해 메세지를 전송하면 실제 객체에 따라 적절한 메소드 실행
            - 내부에서 수행되는 절차는 다를 수 있지만, 다형성은 절차에 대한 로직을 몰라도 됨
            - 객체지향은 이런 절차 추상화 이다.

### 변경을 기준으로 선택하라

- 단순히 클래스를 구현 단위로 사용한다고 객체지향이 아님
- 타입을 기준으로 절차 추상화를 하지 않았다면 객체지향 분해가 아님
- 클래스 내부에 인스턴스 타입을 표현하는 변수가 있으면 이것은 객체지향 위반
    - employee 의 타입을 hourly 로 구분하는 경우

      ```jsx
      Employee = Struct.new(:name, :basePay, :hourly, :timeCard) do
        def calculatePay(taxRate)
          if (hourly) then
            return calculateHourlyPay(taxRate)
          end
          return calculateSalariedPay(taxRate)
        end
      
        def monthlyBasePay()
          if (hourly) then return 0 end
          return basePay
        end
      ```

    - 이건 다형성으로 대체해야 함
        - 기존 코드에 영향을 미치지 않고 새로운 객체 유형과 행위를 추가(개방 폐쇄 원칙)
- 구현 단위를 클래스로 하는 것이 추상 데이터 타입을 기반으로 하는 시스템에서 항상 옳은가?
    - 항상 올바른 해결방법이 아니다
    - 설계는 변경과 관련된 것! → 자주 변경되는 것이 무엇인지 따라 다름
    - 타입이 자주 바뀐다면 객체 지향
        - ADT는 타입이 바뀔때마다 모든 코드를 다 바꿔야함(클라이언트, 타입체크하는 오퍼레이션 등)
    - 오퍼레이션(메소드)가 자주 추가되고 변경된다면 추상데이터타입

### 협력이 중요하다

- 단순히 오퍼레이션과 타입을 표에 적어 놓고, 클래스 계층에 구현방법을 분배한다고 객체지향 프로그램이 되는 것이 아님
- 협력, 역할 책임을 고려하여 객체지향 설계를 해야 함
    - 객체가 참여할 협력을 결정, 협력에 필요한 책임 수행을 위해 어떤 객체가 필요한지 고민
    - 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화
        - 정규직 직원, 인턴, 알바 의 월급계산이 다양해질때?
    - 타입 계층과 다형성은 협력이라는 맥락으로 책임을 수행하는 방법에 관해 고민한 결과물
        - 그 자체가 목적이면 안된다 → 객체가 고립된다